---
layout: default
title: GiveMeItems! - the Mutator
tags: unrealscript mutator givemeitems
---

<div>
	<div class="page-title">
    	GiveMeItems!</div>
	</div>
	<p class="page-title-2">A mutator and GUI addon for Unreal Tournament. A Work in Progress.</p> 
	</br>
	<p class="page-title-2">The Mutator</p> 
	<p class="page-paragraph">The mutator is the component added to an actual game, and is responsible for overriding default monster properties.</p>
	</br>
	<p class="page-title-2">Declaration and Variables</p> 
	<p class="page-paragraph">The mutator code begins with a definition of what the code itself is. It derives from the super or parent class, Mutator, which itself contains all the required methods, functions, and other information to make a mutator. Hence, GiveMeItems is its own class which derives from Mutator. GiveMeItems is bound to a configuration file, which is called "GiveMeItems" and stores information used in the mutator during runtime.</p>
<div class="col-sm-12"><pre class="pre-pad" ><span class="inner-pre" style="color:#00FF99">
class GiveMeItems expands Mutator config(GiveMeItems);

var() config int destroyTime;
var() config String ItemChoice[24];
var class&#60Inventory&#62 IVar[24];
var int i;
var float Selection;

</span></pre>
		</div>
<p class="page-paragraph">To connect the mutator to its relevant configuration file, the keyword 'config' is used and the name of the file is written after it in parentheses, similar to the way one would pass an object to a function. We can also see the 'config' keyword below, next to an int variable called 'destroyTime', and an array of strings called 'ItemChoice'. Here, the purpose of the keyword config is to indicate that these variables can be found in the configuration file that has been loaded. As later explained in the window component section, an in-game GUI allows the modification of contents in the configuration file to be done with greater ease and validation.</p>
<p class="page-paragraph">These variables, however, all begin with the keyword 'var', a convention in Unrealscript, and are necessary for specific tasks essential to the mutator. 'destroyTime' is an integer variable which represents the amount of time, in seconds, that passes before every item added by GiveMeItems is removed from the level. 'ItemChoice[24]' contains 24 elements in an array of String type objects; these strings each represent the textual name of an object (for example, 'Botpack.healthvial' is an Inventory object from the package 'Botpack', and that entire string represents the text name for the object, which would be stored as an element in the array 'ItemChoice'). </p>
<p class="page-paragraph">'var class&#60Inventory&#62 IVar[24]' is another array. However, its element are of a different type - not String as in the former example, but of class&#60Inventory&#62. The angle brackets are placed around the type name, Inventory; and the keyword 'class' is placed before &#60Inventory&#62 to specify the type for the array's elements. The addition of 'class' is done due to the fact that 'Inventory' is a data type specific to Unrealscript, not a primitive type of languages like C and Java (int, or String). However, defining the type inside a pair of angle brackets is not too different from the way C++ vectors are created (for example, "vector &#60int&#62 intVector;").</p>

<p class="page-paragraph">The remaining two variables are of primitive types 'int' and 'float'. 'int i' is a counter variable, used below to process through all elements of an array; 'float Selection' holds a randomly generated number, used to select a random Inventory object in the array IVar.</p>

</br>
<p class="page-title-2">Initializing with PreBeginPlay()</p>
<div class="col-sm-12"><pre class="pre-pad" ><span class="inner-pre" style="color:#00FF99">
function PreBeginPlay()
{
  log("~GiveMeItems - 6/11/2014~");
  log("Initializing Items to load for Monsters...");

  //see below.
  SetTimer(destroyTime, true);
	
  for (i = 0; i &#60 24; i++){
    IVar[i] = class&#60Inventory&#62(DynamicLoadObject(ItemChoice[i], class'Class'));				
    if (IVar[i] == None){
     log("GiveMeItems: Invalid Class for ItemChoice["$i$"], substituting...");
     IVar[i] = class'unrealshare.bandages';} 
    else {
	IVar[i].default.event = 'GMIMutDeleteMe';}
	    }
}

</span></pre>
		</div>
 

<p class="page-paragraph">PreBeginPlay() is where the important things happen. This method is called whenever the programmer wants something to happen prior to any gameplay. When we say "prior to any gameplay," we mean that the loading of a map, the players in the game, and any other modifications used in that round - as well as GiveMeItems - are all calculated and accounted for before the player actually begins playing the game.</p>
<p class="page-paragraph">Thus, it is important that the creation of the Inventory items we want monsters to drop happens prior to any gameplay, rather than during gameplay. After some log messages are broadcast to Unreal's logging system, the first task that is calculated is indicating how often weapons are removed, through 'SetTimer(destroyTime, true)'.</p>

<div class="col-sm-12"><pre class="pre-pad" ><span class="inner-pre" style="color:#FF0099">
//Below is the declaration of the function SetTimer(), and its arguments... 
native final function SetTimer(
    float inRate, 
    bool inbLoop,
);

</span></pre>
		</div>

<p class="page-paragraph">For programmers of Java, the keyword 'final' may seem familiar. This indicates that SetTimer() cannot be overridden or overwritten (its parameters, inRate and inbLoop, cannot be removed or replaced, nor can other parameters be added to this function; nor can a programmer write their own version of the function to make it do something different). The paramter 'inRate' represents a time interval in seconds; the boolean variable 'inbLoop' indicates whether or not the function Timer() will execute the code once, or whether it will execute every 'inRate' seconds. So, if we were to write 'SetTimer(20, true), the method Timer(), which refers to SetTimer(), would run its own code every 20 seconds repeatedly, because 'inRate' would be set to 20, and 'inbLoop' would be set to true.</p>
<p class="page-paragraph">We will return to SetTimer() soon, when we examine another part of this mutator's code. For now, we proceed to a 'for' loop, which contains another important method which is part of Unrealscript - DynamicLoadObject().</p>


	<div class="col-sm-12"><pre class="pre-pad" ><span class="inner-pre" style="color:#00FF99">
for (i = 0; i &#60 24; i++){
    IVar[i] = class&#60Inventory&#62(DynamicLoadObject(ItemChoice[i], class'Class'));				
    if (IVar[i] == None){
     log("GiveMeItems: Invalid Class for ItemChoice["$i$"], substituting...");
     IVar[i] = class'unrealshare.bandages';} 
    else {
	IVar[i].default.event = 'GMIMutDeleteMe';}
	    }

</span></pre>
		</div>
<p class="page-paragraph">The 'for' loop runs 24 times (starting at 0 and ending at 23, because i must be less than 24). A while ago, we saw the declaration of two arrays: 'ItemChoice' and 'IVar'. These arrays can be thought of as "parallel" arrays, due to the fact that they contain the same amount of elements, and also because the information in one of the arrays is related to that of the other. More specifically, we are generating the contents of 'IVar' by using the information stored in 'ItemChoice'.</p>
<p class="page-paragraph">Remember the keyword 'config' that appeared before 'destroyTime' as well as 'ItemChoice[24]'? That keyword indicated that the variable and array have their contents stored in a configuration file, named 'GiveMeItems.ini'. Here is an example of what that .ini file might look like:</p>

<div class="col-sm-12"><pre class="pre-pad" ><span class="inner-pre" style="color:#ffffff">
[GiveMeItems.GiveMeItems]
destroyTime=40
ItemChoice[0]=botpack.eclip
ItemChoice[1]=botpack.eclip
ItemChoice[2]=botpack.eclip
ItemChoice[3]=botpack.ut_shieldbelt
ItemChoice[4]=botpack.ut_shieldbelt
ItemChoice[5]=botpack.ut_shieldbelt
ItemChoice[6]=unreali.nalifruit
ItemChoice[7]=unreali.nalifruit
ItemChoice[8]=unreali.nalifruit
ItemChoice[9]=unreali.flashlight
ItemChoice[10]=unreali.flashlight
ItemChoice[11]=unreali.flashlight
ItemChoice[12]=botpack.thighpads
ItemChoice[13]=botpack.thighpads
ItemChoice[14]=botpack.thighpads
ItemChoice[15]=botpack.healthvial
ItemChoice[16]=botpack.healthvial
ItemChoice[17]=botpack.healthvial
ItemChoice[18]=unreali.jumpboots
ItemChoice[19]=unreali.jumpboots
ItemChoice[20]=unreali.jumpboots
ItemChoice[21]=unreali.scubagear
ItemChoice[22]=unreali.scubagear
ItemChoice[23]=unreali.scubagear

</span></pre>
		</div>


	<div class="col-sm-12"><pre class="pre-pad" ><span class="inner-pre" style="color:#00FF99">
//=============================================================================
// GiveMeItems.
//=============================================================================
class GiveMeItems expands Mutator config(GiveMeItems);

var() config int destroyTime;
var() config String ItemChoice[24];
var class&#60Inventory&#62 IVar[24];
var int i;
var float Selection;

function PreBeginPlay()
{
  log("~GiveMeItems - 6/11/2014~");
  log("Initializing Items to load for Monsters...");

  //see below.
  SetTimer(destroyTime, true);
	
  for (i = 0; i &#60 24; i++){
    IVar[i] = class&#60Inventory&#62(DynamicLoadObject(ItemChoice[i], class'Class'));				
    if (IVar[i] == None){
     log("GiveMeItems: Invalid Class for ItemChoice["$i$"], substituting...");
     IVar[i] = class'unrealshare.bandages';} 
    else {
	IVar[i].default.event = 'GMIMutDeleteMe';}
	    }
}


function Timer(){

  local inventory inv;

  foreach allactors(class'inventory', inv){
  if (inv.event == 'GMIMutDeleteMe' && inv.IsInState('pickup')){
	inv.destroy();}
	}
}

function bool CheckReplacement(Actor Other, out byte bSuperRelevant) 
{ 
		
  Selection = Rand(24);
		
  if (Selection &#60 24){
  	if(Other.IsA('ScriptedPawn') && 
	   ScriptedPawn(Other).DropWhenKilled == None){
		ScriptedPawn(Other).DropWhenKilled = IVar[Selection];} 
 				}
  return true; 
            
  }             
} </span></pre>
		</div>
