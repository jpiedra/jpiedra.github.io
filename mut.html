---
layout: default
title: GiveMeItems! - the Mutator
tags: unrealscript mutator givemeitems
---

<div>
	<div class="page-title">
    	GiveMeItems!</div>
	</div>
	<p class="page-title-2">A mutator and GUI addon for Unreal Tournament. A Work in Progress.</p> 
	</br>
	<p class="page-title-2">The Mutator</p> 
	<p class="page-paragraph">The mutator is the component added to an actual game, and is responsible for overriding default monster properties.</p>
	</br>
	<p class="page-title-2">Declaration and Variables</p> 
	<p class="page-paragraph">The mutator code begins with a definition of what the code itself is. It derives from the super or parent class, Mutator, which itself contains all the required methods, functions, and other information to make a mutator. Hence, GiveMeItems is its own class which derives from Mutator. GiveMeItems is bound to a configuration file, which is called "GiveMeItems" and stores information used in the mutator during runtime.</p>
<div class="col-sm-12"><pre class="pre-pad" ><span class="inner-pre" style="color:#00FF99">
class GiveMeItems expands Mutator config(GiveMeItems);

var() config int destroyTime;
var() config String ItemChoice[24];
var class&#60Inventory&#62 IVar[24];
var int i;
var float Selection;

</span></pre>
		</div>
<p class="page-paragraph">To connect the mutator to its relevant configuration file, the keyword 'config' is used and the name of the file is written after it in parentheses, similar to the way one would pass an object to a function. We can also see the 'config' keyword below, next to an int variable called 'destroyTime', and an array of strings called 'ItemChoice'. Here, the purpose of the keyword config is to indicate that these variables can be found in the configuration file that has been loaded. As later explained in the window component section, an in-game GUI allows the modification of contents in the configuration file to be done with greater ease and validation.</p>
<p class="page-paragraph">These variables, however, all begin with the keyword 'var', a convention in Unrealscript, and are necessary for specific tasks essential to the mutator. 'destroyTime' is an integer variable which represents the amount of time, in seconds, that passes before every item added by GiveMeItems is removed from the level. 'ItemChoice[24]' contains 24 elements in an array of String type objects; these strings each represent the textual name of an object (for example, 'Botpack.healthvial' is an Inventory object from the package 'Botpack', and that entire string represents the text name for the object, which would be stored as an element in the array 'ItemChoice'). </p>
<p class="page-paragraph">'var class&#60Inventory&#62 IVar[24]' is another array. However, its element are of a different type - not String as in the former example, but of class&#60Inventory&#62. The angle brackets are placed around the type name, Inventory; and the keyword 'class' is placed before &#60Inventory&#62 to specify the type for the array's elements. The addition of 'class' is done due to the fact that 'Inventory' is a data type specific to Unrealscript, not a primitive type of languages like C and Java (int, or String). However, defining the type inside a pair of angle brackets is not too different from the way C++ vectors are created (for example, "vector &#60int&#62 intVector;").</p>

<p class="page-paragraph">The remaining two variables are of primitive types 'int' and 'float'. 'int i' is a counter variable, used below to process through all elements of an array; 'float Selection' holds a randomly generated number, used to select a random Inventory object in the array IVar.</p>

</br>
<p class="page-title-2">Initializing with PreBeginPlay()</p>
<div class="col-sm-12"><pre class="pre-pad" ><span class="inner-pre" style="color:#00FF99">
function PreBeginPlay()
{
  log("~GiveMeItems - 6/11/2014~");
  log("Initializing Items to load for Monsters...");

  //see below.
  SetTimer(destroyTime, true);
	
  for (i = 0; i &#60 24; i++){
    IVar[i] = class&#60Inventory&#62(DynamicLoadObject(ItemChoice[i], class'Class'));				
    if (IVar[i] == None){
     log("GiveMeItems: Invalid Class for ItemChoice["$i$"], substituting...");
     IVar[i] = class'unrealshare.bandages';} 
    else {
	IVar[i].default.event = 'GMIMutDeleteMe';}
	    }
}

</span></pre>
		</div>
 

<p class="page-paragraph">PreBeginPlay() is where the important things happen. This method is called whenever the programmer wants something to happen prior to any gameplay. When we say "prior to any gameplay," we mean that the loading of a map, the players in the game, and any other modifications used in that round - as well as GiveMeItems - are all calculated and accounted for before the player actually begins playing the game.</p>
<p class="page-paragraph">Thus, it is important that the creation of the Inventory items we want monsters to drop happens prior to any gameplay, rather than during gameplay. After some log messages are broadcast to Unreal's logging system, the first task that is calculated is indicating how often weapons are removed, through 'SetTimer(destroyTime, true)'.</p>

<div class="col-sm-12"><pre class="pre-pad" ><span class="inner-pre" style="color:#FF0099">
//Below is the declaration of the function SetTimer(), and its arguments... 
native final function SetTimer(
    float inRate, 
    bool inbLoop,
);

</span></pre>
		</div>

<p class="page-paragraph">For programmers of Java, the keyword 'final' may seem familiar. This indicates that SetTimer() cannot be overridden or overwritten (its parameters, inRate and inbLoop, cannot be removed or replaced, nor can other parameters be added to this function; nor can a programmer write their own version of the function to make it do something different). The paramter 'inRate' represents a time interval in seconds; the boolean variable 'inbLoop' indicates whether or not the function Timer() will execute the code once, or whether it will execute every 'inRate' seconds. So, if we were to write 'SetTimer(20, true), the method Timer(), which refers to SetTimer(), would run its own code every 20 seconds repeatedly, because 'inRate' would be set to 20, and 'inbLoop' would be set to true.</p>
<p class="page-paragraph">We will return to SetTimer() soon, when we examine another part of this mutator's code. For now, we proceed to a 'for' loop, which contains another important method which is part of Unrealscript - DynamicLoadObject().</p>


	<div class="col-sm-12"><pre class="pre-pad" ><span class="inner-pre" style="color:#00FF99">
for (i = 0; i &#60 24; i++){
    IVar[i] = class&#60Inventory&#62(DynamicLoadObject(ItemChoice[i], class'Class'));				
    if (IVar[i] == None){
     log("GiveMeItems: Invalid Class for ItemChoice["$i$"], substituting...");
     IVar[i] = class'unrealshare.bandages';} 
    else {
	IVar[i].default.event = 'GMIMutDeleteMe';}
	    }

</span></pre>
		</div>
<p class="page-paragraph">The 'for' loop runs 24 times (starting at 0 and ending at 23, because i must be less than 24). A while ago, we saw the declaration of two arrays: 'ItemChoice' and 'IVar'. These arrays can be thought of as "parallel" arrays, due to the fact that they contain the same amount of elements, and also because the information in one of the arrays is related to that of the other. More specifically, we are generating the contents of 'IVar' by using the information stored in 'ItemChoice'.</p>
<p class="page-paragraph">Remember the keyword 'config' that appeared before 'destroyTime' as well as 'ItemChoice[24]'? That keyword indicated that the variable and array have their contents stored in a configuration file, named 'GiveMeItems.ini'. Here is an example of what that .ini file might look like:</p>

<div class="col-sm-12"><pre class="pre-pad" ><span class="inner-pre" style="color:#ffffff">
[GiveMeItems.GiveMeItems]
destroyTime=40
ItemChoice[0]=botpack.eclip
ItemChoice[1]=botpack.eclip
ItemChoice[2]=botpack.eclip
ItemChoice[3]=botpack.ut_shieldbelt
ItemChoice[4]=botpack.ut_shieldbelt
ItemChoice[5]=botpack.ut_shieldbelt
ItemChoice[6]=unreali.nalifruit
ItemChoice[7]=unreali.nalifruit
ItemChoice[8]=unreali.nalifruit
ItemChoice[9]=unreali.flashlight
ItemChoice[10]=unreali.flashlight
ItemChoice[11]=unreali.flashlight
ItemChoice[12]=botpack.thighpads
ItemChoice[13]=botpack.thighpads
ItemChoice[14]=botpack.thighpads
ItemChoice[15]=botpack.healthvial
ItemChoice[16]=botpack.healthvial
ItemChoice[17]=botpack.healthvial
ItemChoice[18]=unreali.jumpboots
ItemChoice[19]=unreali.jumpboots
ItemChoice[20]=unreali.jumpboots
ItemChoice[21]=unreali.scubagear
ItemChoice[22]=unreali.scubagear
ItemChoice[23]=unreali.scubagear

</span></pre>
		</div>
<p class="page-paragraph">The header of this file, '[GiveMeItems.GiveMeItems]' indicates that this file is used in the class 'GiveMeItems', which belongs to the package by the same name called 'GiveMeItems'. As with the previous example, 'Botpack.healthvial', the phrase before the period indicates the name of the package, and the phrase after the period indicates the name of the object that is in that package - in this instance, they both happen to be the same (or, the mutator 'GiveMeItems' is an object of the package called 'GiveMeItems' - just like the inventory object 'healthvial' is an object of the package called 'BotPack').</p>
<p class="page-paragraph">Following that header we see that the contents of 'destroyTime' as well as the elements in 'ItemChoice' have all been provided. When the mutator runs, it will actually derive the value for 'destroyTime' from this file, and that value will get passed to 'SetTimer()'.</p>
<p class="page-paragraph">Similarly, the Strings contained in the elements of 'ItemChoice' are used by DynamicLoadObject().</p>

<div class="col-sm-12"><pre class="pre-pad" ><span class="inner-pre" style="color:#FF0099">
//Below are the declaration and arguments of DynamicLoadObject()
native static final function object DynamicLoadObject( 
 string ObjectName, 
 class ObjectClass, 
 optional bool MayFail );

</span></pre>
		</div>
<p class="page-paragraph">DynamicLoadObject() accepts, first, a String variable, 'ObjectName', which represents the text representation of an object's name. Note the keyword 'object' which comes before 'DynamicLoadObject()'. This indicates the return type of this function; so, this function will return an 'object,' whose name is 'ObjectName', which is of a certain class type. The second parameter, 'ObjectClass', indicates what class that object derives from (in other words, what type of object 'ObjectName' is. The third parameter, 'MayFail', is an optional boolean variable; if it is set to true, the possibility of a failed call to DynamicLoadObject() will cause a log message to be printed.<p>
<div class="col-sm-12"><pre class="pre-pad" ><span class="inner-pre" style="color:#00FF99">
for (i = 0; i &#60 24; i++){
    IVar[i] = class&#60Inventory&#62(DynamicLoadObject(ItemChoice[i], class'Class'));				
    if (IVar[i] == None){
     log("GiveMeItems: Invalid Class for ItemChoice["$i$"], substituting...");
     IVar[i] = class'unrealshare.bandages';} 
    else {
	IVar[i].default.event = 'GMIMutDeleteMe';}
	    }

</span></pre>
		</div>

<p class="page-paragraph">This loop does several things. First, it initializes an element of 'IVar' with an object of class&#60Inventory&#62. The text name for an object, stored in the corresponding element of the parallel array 'ItemChoice' is entered as the first parameter to DynamicLoadObject(). Second, the method will then attempt to load an object by that name, of class type 'Class', which is the type under which all different classes fall and are derived from. However, we only want 'Inventory' class objects. So, lastly, the class&#60Inventory&#62 statement is placed next to the call to DynamicLoadObject, because we want to store whatever object the function returns as an 'Inventory' class object. That 'Inventory' class object is what gets stored as an element of 'IVar', for use later.<p>

<p class="page-paragraph">An object returned by DynamicLoadObject() is stored as an object of type 'class&#60Inventory&#'. However, this storage may not always be successful. In that situation, a non-Inventory type object (for example, 'Unreali.mercenary', which is of type 'ScriptedPawn', not 'Inventory') will not be stored into an 'IVar' element because it cannot be stored as an 'Inventory' typeobject. Instead, the element remains uninitialized, or 'IVar[i] = None'. This situaton is also handled in the loop; the statement "if (IVar[i] == None)" checks to see if 'IVar' contains an inventory item or not; if it contains 'None', or no item, then a generic item is substituted - 'unreali.bandages'. <p>


	<div class="col-sm-12"><pre class="pre-pad" ><span class="inner-pre" style="color:#00FF99">
//=============================================================================
// GiveMeItems.
//=============================================================================
class GiveMeItems expands Mutator config(GiveMeItems);

var() config int destroyTime;
var() config String ItemChoice[24];
var class&#60Inventory&#62 IVar[24];
var int i;
var float Selection;

function PreBeginPlay()
{
  log("~GiveMeItems - 6/11/2014~");
  log("Initializing Items to load for Monsters...");

  //see below.
  SetTimer(destroyTime, true);
	
  for (i = 0; i &#60 24; i++){
    IVar[i] = class&#60Inventory&#62(DynamicLoadObject(ItemChoice[i], class'Class'));				
    if (IVar[i] == None){
     log("GiveMeItems: Invalid Class for ItemChoice["$i$"], substituting...");
     IVar[i] = class'unrealshare.bandages';} 
    else {
	IVar[i].default.event = 'GMIMutDeleteMe';}
	    }
}


function Timer(){

  local inventory inv;

  foreach allactors(class'inventory', inv){
  if (inv.event == 'GMIMutDeleteMe' && inv.IsInState('pickup')){
	inv.destroy();}
	}
}

function bool CheckReplacement(Actor Other, out byte bSuperRelevant) 
{ 
		
  Selection = Rand(24);
		
  if (Selection &#60 24){
  	if(Other.IsA('ScriptedPawn') && 
	   ScriptedPawn(Other).DropWhenKilled == None){
		ScriptedPawn(Other).DropWhenKilled = IVar[Selection];} 
 				}
  return true; 
            
  }             
} </span></pre>
		</div>
