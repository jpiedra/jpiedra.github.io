---
layout: post
title: Maze generation with Python -- Prelude
date: 2015-09-21
comments: true
archive: false
author: Jonathan Piedra
tags: python maze
---
<p>In the spirit of learning a new language through developing projects, I recently revisted an old game I made to see what I could improve. It turns out, in contrast to the language used previously, that Python is well-suited for writing compact, efficient code in the context of a simple maze generation module. This post aims to serve as an introduction to Python's basic features; it will also discuss built-in data structures that will prove very helpful towards creating maze generation algorithms.</p>

<p><a href="https://www.python.org" title="Python Homepage">Python</a> is an interactive programming language designed by Guido van Rossum, and has been on the scene since 1991. It boasts a variety of useful, built-in data structures, as well as a comprehensive approach to introspection - anything you create in Python is an object with many useful methods for retreving documentation, modifying contents, and more.</p>

<h1>Installation</h1>
<p>For Windows users, various installers are available depending on the version you require. For Linux users, depending on your Linux distribution, you should be able to install Python manually through the command line using Advanced Packaging Tool: <code>sudo apt-get install python</code></p>
<p>And if you want a specific Python version or library, you'll also be able to search through related files by running: <code>sudo apt-cache search python</code> and then installing whatever you require.</p>
<h1>Example 1: Some Primitive Types</h1>
<p>Here's a small code snippet to demonstrate some of Python's syntax and features:</p>
<pre>
#This is a comment; below is a Dictionary
dict = {'first':1, 'second':2, 'third':3}

#Create and initialize a List using Python's range() method
li = [v for v in range(0, 10)]

#We can also initialize an empty List
empty_li = []

#A Tuple cannot be changed once it is created
tup = ('Jon', 'Piedra')
</pre>
<p>Using your terminal, running <code>python</code> will open Python's interactive command line, where you have access to Python's runtime environment until you close out of this session (Ctrl+D). This is very useful for getting a quick feel for Python's features, and - as we'll see later - running tests on more fleshed-out programs. (Another useful keyboard shortcut is Ctrl+L, which will clear the current terminal by erasing the input/output of previous commands. These shortcuts are for your terminal in general, not just Python!)</p>
<p>Now, after entering the Python terminal, enter all the non-comment statements (anything that doesn't begin with the # symbol). You won't get any output; that's fine. We are simply creating some primitive types and initializing their contents. Next, we'll see what the results of these statements are.</p>
<ul>
<li>
<p><code>dict = {'first':1, 'second':2, 'third':3}</code> creates a dictionary. Dictionaries are associative arrays, so where we might normally expect to obtain an array's value by its numeric index (myArray[0]), we instead have several ways of accessing dictionary contents. One of the more immediate ways of doing this is through using the <b>key</b> of a desire element as the index; in a dictionary, every element is a pair consisting of one key (left-hand item) and a value (right-hand item) seperated by a colon ':' character.</p>
<p>Run <code>print dict['first']</code> to print out the <b>value</b> that the key 'first' references.</p>
<p>Dictionaries in Python are mutable, which is just a way of saying we can change the value a key refers to even after we initialize it to something. Enter <code>dict['second']=222</code>, then follow that by entering <code>print dict['second']</code> to see that, indeed, the contents of dict['second'] were changed from their former value of 2 to a new value, 222.</p>
</li>
<li>
<p><code>li = [v for v in range(0, 10)]</code> creates a list. Lists in Python are closer to arrays in languages like C++, C, Java, etc. However, there are some useful things we can do with lists in Python that make standard operations like initializing lists a bit easier. For example: in this statement, we're actually using a Python method - <code>range(start, stop[, step])</code> - to populate our list in a single expression embedded within the array subscript operators ([ ]), rather than relying on a for-loop to do the same thing.</p>
<p>The statement <code>v for v in range(0, 10)</code> causes a list to be returned, containing all the integers in the range from (and including) 0 up to (excluding) 10. This resulting list is what is assigned the variable name <b>li</b>. You may have noticed a third argument in the definition of the function above, the <b>[, step]</b> argument. This argument will modify the output we get based on the first two argument, returning every Nth element rather than every consecutive one. Try typing: <code>liB = [x for x in range(0, 10, 2)]</code>, then <code>print liB</code> to see what the step argument does first-hand.</p>
<p>Run <code>print dict['first']</code> to print out the <b>value</b> that the key 'first' references.</p>
<p>Lists are also mutable, and changing the contents of a list element is easy enough. Just use the index of the desired element you want to change, and assign that element a new value. By the way: the value doesn't have to be an intger. Lists can store variables of different data types, so <code>li[0] = 'String'</code> will cause the first element to hold a String.</p>
</li>
<li>
<p><code>tup = ('Jon', 'Piedra')</code> creates a tuple. A tuple is an immutable collection; once you initialize a tuple, you cannot change that tuple's contents afterwards. Doing so will cause Python to become rather upset with you, even if I all want to do is get a cool nickname:</p>
<pre>
>>> tup = ('Jon','Piedra')
>>> tup[0] = 'Johny'
Traceback (most recent call last):
  File "&ltstdin&gt", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
</pre>
<p>Alas, some things will never be. Anyway, if you need a mutable object, use a list or dictionary. As we'll see in later posts/examples, though, tuples do have their uses. We don't always need mutable objects, and we may come across cases where the values we need to choose from in some sort of algorithm are fixed and unchanging throughout runtime - in such cases, tuples are just the thing.</p>
<p>Tuples are collections of values, not key/value pairs. For this reason, the list-like indexing operator is used to access a value inside a tuple. As in C-like language, tuples/lists are zero-indexed, so <code>print tup[0]</code> will cause 'Jon' to print out to the terminal.</p>
</li>
</ul>
<p>These are some of the basic data structures Python offers. Of course, Python includes other primitive data types like integers, floating point numbers, and others that experienced programmers would expect. Python also uses a versatile object-oriented system, which will be discussed in the next post, where we get around to creating a simple object for maze generation.</p>
<h1>Example 2: Operations on Lists</h1>

<pre>
>>> stuff = ['alpha', 'bravo', 'charlie']
>>> print stuff
['alpha', 'bravo', 'charlie']
>>> stuff = stuff + ['delta']
>>> print stuff
['alpha', 'bravo', 'charlie', 'delta']
>>> stuff += ['epsilon']
>>> print stuff
['alpha', 'bravo', 'charlie', 'delta', 'epsilon']
</pre>
<p><i>List concatenation</i> allows us to add elements to a list using some simple operators. Above, we have two ways of appending (adding) a new member to the list <b>stuff</b> that, while different in appearance, do the same thing. <code>stuff = stuff + ['delta']</code> uses a single plus symbol to append whatever's on the right side to the list on the left - then uses the assignment operator, <b>=</b> to assign the results to <b>stuff</b>.</p>
<p>The second example of list concatenation, <code>stuff += ['epsilon']</code> uses <a href="https://en.wikipedia.org/wiki/augmented_assignment" title="Wikipedia: Augmented Assignment">augmented assignment</a> to append a new value to the list <b>stuff</b>. A more detailed explanation of what augmented assignment is can be found at the provided link; the general takeaway here is that this amounts to the same thing as <code>stuff = stuff + ['epsilon']</code>, but is much more compact through the combination of concatenation and assignment into a single operator, <b>+=</b>.</p>

<pre>
>>> numbers = [2, 4, 8] * 3
>>> print numbers
[2, 4, 8, 2, 4, 8, 2, 4, 8]
</pre>
<p><i>The repeater operator</i> offers a quick way to create a list, or repeatedly append to a list, using a series of fixed values. In the example above, <code>numbers = [2, 4, 8] * 3</code> demonstrates how the asterisk operator, will cause a new list, <b>numbers</b>, to be assigned by building a list made of three sequences of the numbers 2, 4, and 8 in that order.</p>
<p>For a more detailed description of Python's list operations, among many other features, I highly recommend <i>Dive into Python 2</i>, a comprehensive introductory text to the language that gets you writing and examining code right away. <a href="http://www.diveintopython.net/native_data_types/lists.html#d0e6392" title="Dive Into Python 2: List Operations">Here's a link</a> to the section of the text pertaining to list operators. For the purposes of this small series, though, these operators should suffice for the goal of creating a maze-generation module.</p>

<h1>Something Old, Something New</h1>
<p>Speaking of mazes, let's talk about the old project I mentioned earlier. I create an extremely basic, MEAN stack website that hosted a game written in JavaScript. The game was a small maze crawler that would load levels stored in a MongoDB database instance, and use these level layouts to generate a random level on the fly. Some things worked well; others didn't. Among these, the idea of having a database store level blueprints was interesting at the time (and, more importantly, gave me an excuse to learn and mess around with MongoDB), but it became clear that having an alternate option - perhaps if the instance went offline - for level creation would be advantageous.</p>
<p>Fortunately, there's a variety of maze generation algorithms out there (and likely the projects of others who have implemented these) to address such a need. But, as is often the case with programming, sometimes it's more fun to roll your own; implementing a maze algorithm in the language of your choice is a great learning exercise. <a href="http://www.jamisbuck.org/presentations/rubyconf2011" title="Presentation on Maze Algorithms, by Jamis Buck">But don't just take my word for it.</a></p>
<p>Here's the approach I adopted in that JS game: I created a fixed member of mazeGraph, a list of lists (or, a two-dimensional list).</p>

<pre>
var mazeGraph = function() {
	this.nodes = 			
	[				//Outer List
		[<b style="color:red">1</b>,0,1,0,1,0,1,0,1,0,1,0], 	//Inner Lists
		[<b style="color:blue">0</b>,0,0,0,0,0,0,0,0,0,0,0],
		[1,0,1,0,1,0,1,0,1,0,1,0],
		[0,0,0,0,0,0,0,0,0,0,0,0],
		[1,0,1,0,1,0,1,0,1,0,1,0],
		[0,0,0,0,0,0,0,0,0,0,0,0],
		[1,0,1,0,1,0,1,0,1,0,1,0],
		[0,0,0,0,0,0,0,0,0,0,0,0],
		[1,0,1,0,1,0,1,0,1,0,1,0],
		[0,0,0,0,0,0,0,0,0,0,0,0],
		[1,0,1,0,1,0,1,0,1,0,1,0],
		[0,0,0,0,0,0,0,0,0,0,0,0] 	//End of Inner Lists	
	];				//End of Outer List
};
</pre>
<p>This is a straight-forward way of representing a 2-dimensional grid. Before explaining how that works, it's necesarry to mention how a 2d list works. Recall that, to access an element in a list, we just use the index of that element like so: myList[0] will yield the first element in myList. If, however, we have a list where every contained element is <i>also a list,</i> then we will have to index twice: Once for an element in the outer list, and then again for an element in that inner list.</p>
<p>We can illustrate this with <code>mazeGraph.nodes[0][0]</code>. That basically means:<p>
<ol>
<li>Access the first element in mazeGraph.nodes - mazeGraph.node[0].</li>
<li>This gives use the first inner list; now, access the first elment in that list by adding another pair of square brackets, and a 0 index - mazeGraph.node[0][0].</li>
</ol>
<p>The value stored at <code>mazeGraph.node[0][0]</code> is <b style="color:red">1</b>. Following from the explanantion provided above, <code>mazeGraph.node[1][0]</code> will be <b style="color:blue">0</b>.
<p>How is this useful for representing a 2d grid? Well, if we create a rectangular 2d list by making sure every inner list is the same length (holds the same number of items), then we have a coordinate plane that is [number of inner lists] by [length of any inner list] wide. If we treat the first inner list's first element as the grid's origin - mazeGraph.nodes[0][0] - then we can navigate to any point in our grid by modifying the element indexes to reflect our desired location. This is one important distinction to make from the way we normally think about coordinate planes, where the origin coordinate (0, 0) occurs directly in the middle, or on the bottom-left corner if we're not considering negative coordinate points. As a consequence of this, our 2d grid will have points farther away from the origin occur <i>south-east</i> of the origin, in contrast to the points on a standard coordinate plane of positive values - which occur <i>north-east</i> of the origin.</p>
<p>One more distinction to make: In coordinate geometry, the convention is to list the x-coordinate followed by the y-coordinate, so (3,4) would be the point at x-coordinate 3 and y-coordinate 4. If we want to use a 2d-array to represent a coordinate plane, then we'll have to flip that around: the first pair of square brackets will refer to the y-coordinate, and the second pair will refer to the x-coordinate. Recall the contents of <code>mazeGraph.node[1][0]</code> and this makes sense: that's a location 1 point away from the origin along the y-axis, but it hasn't moved along the x-axis at all, so the first pair of brackets is [1] and the second pair is [0].</p>
<h1>Moving Forward</h1>
<p>This post is already getting quite long, so let's end things here for now. The next post will discuss some other features of Python, specifically defining functions, and will also include and expand upon our previous discussion of Python's data structures. The post will also demonstrate a more flexible way of setting up a grid for maze generation in Python; using a function, we'll be able to not only initialize a blank grid, but also specify the dimensions we want for our grid - something that is certainly possible in JavaScript, but which I enjoyed learning how to do in Python.</p>

