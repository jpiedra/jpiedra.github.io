---
layout: post
title: As Seen On My Blog -- jQuery Link Aggregation
date: 2015-09-26
comments: true
archive: false
author: Jonathan Piedra
tags: javascript webdev
---
<p>In a series of occasional posts, I'll describe in detail some of the minor features of my blog and how I used different libraries and frameworks to get them working. To start this series, let's look at a very small but useful snippet of JavaScript/jQuery that appends a list of links used in a post.</p>

<p>I like to include links in my posts to external resources, mainly for the purpose of assisting anyone reading along but also to demonstrate the awesome thing about the internet - it's really possible to learn anything if you know where to look. It's been the case for myself, trying to get a NodeJS page deployed that posts to and reads from a database, or learning x86 assembly language just to do it, among other things.</p> 
<p>Even in the process of setting up and improving my Jekyll blog, this has proven to be the case, demonstrating that there's an opportunity for learning just about anywhere. I had, and still mull over, some ideas about how I want the blog to look - everything from the front page, to each post, and plenty of other aspects. For example, I knew I wanted each post to conclude with a list of all the materials linked to in it. I knew from prior experience that JavaScript and jQuery would be involved, along with some basic HTML to handle formatting the list of links. This is the fun in web design (or coding anything, really): using a combination of prior knowledge, research and imagination to come up with a solution.</p>
<h1>jQuery Link Aggregation</h1>
<p>Below is the code I used to aggregate a list of links and append that list to the bottom of a post.</p>
<pre>
$(document).ready(function(){
  <b style="color: green">var $postLinks = </b><b style="color: red">$( ".jp-post-body" )</b><b style="color: blue">.find( "a" );</b>
  if ($postLinks.length !== 0) {
    $(".posted-links").append("&lth1&gtRelated Reading&lt/h1&gt");
    $(".posted-links").append("&ltul class='pl-list'&gt&lt/ul&gt");
    for(i = 0; i &lt $postLinks.length; i++) {
      $(".pl-list").append( "&ltli id=" + "link" + i + "&gt&lt/li&gt");
      $("#link" + i).append( "&lta href='" + $( $postLinks[i] ).prop( "href" ) + "'&gt" + $( $postLinks[i] ).prop( "title" ) + "&lt/a&gt");
    };		
  };	
});
</pre>
<p><a href="http://jquery.com/" title="jQuery Official Homepage">jQuery</a> is a popular and powerful JavaScript library used to add functionality and interactivity to webpages - from CSS formatting, AJAX requests, element traversal, and much more. Several jQuery methods, along with standard JavaScript, are combined to find all the links in my page, then locate other elements that already exist in the post page and append an unordered list. Then, the links we collected are appended to that list as individual items.</p>
<p>I'll provide a very general explanation of how jQuery code is included in a page. We begin by wrapping our own code in an anonymous function that we pass to <code>$(document).ready( ... );</code> where the ellipsis gets replaced with the anonymous function. An anonymous function is a function we define in-line, without a name we would normally use to call it later. When you see <code>function(arguments){code block}</code>, that's an anonymous function - indicated by using the reserved word <b>function</b>, a list of (arguments) in parentheses, and the {code block} in curly braces. This has its uses; we may need to execute some block of code only once. That's what we're doing here, when we pass an anonymous function to the jQuery method <code>.ready( ... )</code>, passing a function that performs the necesarry modifications to the document (the post page) when the page is loaded.</p>
<h1>Class and ID Selectors</h1>
<p>Let's dive into the anonymous function itself. I've highlighted specific portions of the code to facilitate explanation. Highlighted in red, there's a standard use of a jQuery method: the portion <code>$(".jp-post-body")</code> specifies the element in our page to call the <code>find()</code> method through, using the class of that element as an identifier. Because there's an element in my page that uses the class, <b>jp-post-body</b>, indicated using the class selector - <code>&ltdiv class="row jp-post-body"&gt...&lt/div&gt</code> - that element will be found and the jQuery method call will be able to do what we need it to do with that element. (In jQuery, selectors work by supplying a string, surrounded in quotes, of the name of a class or id for an element. This string is then preceded by the appropriate marker - a period for classes, or the <b>#</b> symbol for id. If we had an HTML element with id set to <code>id="jp-post-body"</code>, then we'd have to modify the selector to be <code>$("#jp-post-body")</code> to specify that id)</p>
<h1>Using the jQuery Method .find()</h1>
<p>You'll find, highlighted in blue, the jQuery method we're using - <a href="http://api.jquery.com/find/" title="jQuery API: .find() Method">.find()</a> - to traverse the element we indicated using a selector and locate all elements of a specific type (using an element type, but we could also use a selector - hence, the two function prototypes seen in the API link). The method call <code>.find( "a" );</code> accepts, as a string literal, the name of the element we're looking for occurences of - in our case, the anchor tag, which creates hyperlinks to external resources and webpages. Combined with that previous selector, we get <code>$( ".jp-post-body" ).find( "a" );</code> which will find all the anchor elements in the element using the class <b>jp-post-body</b>, and store the result in the variable <code>var $postLinks</code>, highlighted in green. (By convention, we name JavaScript variables that store jQuery objects with a dollar sign $ symbol as the first character, to make it clearer that the variable is a jQuery object)</p>
<p>After this call, the jQuery method <i>"will return a jQuery collection which contains only the... elements that are descendants of"</i> the element we indicated with the class selector - and the resulting collection will get stored in our variable <b>$postLinks</b>, so we can work with those elements later. Being able to perform these operations on specific HTML elements, by class or id, is extremely useful. Consider what would happen if we couldn't do this: my posts have links embedded that link to external pages, but also include links at the top to post indexes where you can view all posts on my page by the tag they're filed under. We don't want those anchor elements in our list, and if we could only get all the tags in an HTML page, rather than those in a specific element, then our collection would include links to the tag pages as well.</p>
<h1>The .append() Method</h1>
<p>The rest of the work this script occurs inside of an if-statement, only occurring if we actually have anchor elements in our post. If the size of our <b>$postLinks</b> collection is 0, we don't need to append a list of links to our post because we don't have any!</p>
<p>If we have links in our post's body, then there's some work to do. The <a href="http://api.jquery.com/append/" title="jQuery API: .append() Method">.append() method</a> will handle a great deal of what is done next. Here's what happens:</p>
<ol>
<li>
Our page includes an element with the class <b>posted-links</b>, but it's empty at the moment. <code>$(".posted-links").append("&lth1&gtRelated Reading&lt/h1&gt");</code> will cause a new <b>h1</b> element to be added as a child to the element we specified with a class selector, <b>.posted-links</b>. Note that <code>.append()</code> accepts a string literal that includes the element we want to add, surrounded by the appropriate tags, as well as the contents we want that tag to display - sandwiched between the two tags.
</li>
<li>
Next, we call append again, to set up an unordered list and append it to the same element with a class <b>.posted-links</b>. <code>$(".posted-links").append("&ltul class='pl-list'&gt&lt/ul&gt");</code> is pretty similar to the previous call, with one minor and important detail: we also assign a class to the <b>ul</b> element. We just surround the class name with single-quotes, because the argument we pass to <code>.append()</code> is already surrounded by double-quotes.
</li>
<li>
We use a for-loop to iterate through the jQuery object we acquired from the <code>.find()</code> method call. For every element (anchor element) in the jQuery object, we append a new list item with a unique id. We build an id on the fly, using the value of <b>i</b> upon every interation and concatenating it with the literal "link" to get names like "link1", "link2", etc. for each anchor element.
</li>
<li>
Lastly, we append the contents of every anchor element in the jQuery object to its corresponding list item, building a new anchor element with the title attribute as the element's content (the href for each tag stays the same). Because the list items were assigned a unique id, we use an id selector <b>"#link"+i</b> to access the appropriate element (the element id will be the resulting string literal created by concatenating "link" with i). The method call <code>$("#link" + i).append( "&lta href='" + $( $postLinks[i] ).prop( "href" ) + "'&gt" + $( $postLinks[i] ).prop( "title" ) + "&lt/a&gt");</code> also combines use of <a href="http://api.jquery.com/prop/" title="jQuery API: .prop() Method">another jQuery method, .prop(),</a> which will return the value of the <b>href</b> and the <b>title</b> properties for each anchor element.
</li>
</ol>
<h1>Conclusion</h1>
<p>A combination of standard JavaScript and jQuery methods allows us to handle a routine task very easily. As long as the blog author takes the additional step of specifying a <b>title</b> property for every post, the added work of creating a list of links at the end of every post is handled automatically. In the end, this is highly preferable to manually writing in a list of the links for every post written. This just scratches the surface; jQuery is a robust library that offers a variety of useful methods that can be combined in ways that make the designer's life much easier.</p>
