---
layout: post
title: Maze generation with Python -- Part 1, A Grid-Creating Function
date: 2015-09-23
comments: true
archive: false
author: Jonathan Piedra
tags: python maze
---
<p>Defining functions in Python is easy, if not a bit different from the process in C-like languages. The designer of a program has a few new things to learn as well as utilize towards this end. As we'll soon see, though, Python's approach can make for concise, readable and versatile functions.</p>

<h1>Functions in Python</h1>
<p>In Python, functions are defined using the <b>def</b> keyword, like so:</p>
<pre>
def myFunction(arg_a, arg_b=20):
    print "Sum is: %s" % (arg_a + arg_b)
    return
</pre>
<p>You can define such a function in your interactive Python terminal, by typing in the contents of each line and then pressing enter. Note, however, that you must indent (spaces or tabs, but only one of the two - and use the same number of spaces every line) <i>every</i> statement you wish to occur inside <b>myFunction</b>. Here's what your terminal might look like after you do this (I also call the function with a single parameter; I'll explain this later):
<pre>
>>> def myFunction(arg_a, arg_b=20):
...     print "Sum is: %s" % (arg_a + arg_b)
...     return
... 
>>> myFunction(30)
Sum is: 50
</pre>
<p>On that blank line shown above, preceeded by '...', we don't enter anything characters or spaces, we just press the 'Enter' key. This tells the interactive terminal that we're done writing our function, and we return to the standard prompt - on my system, that's indicated by the presence of '>>>' characters.</p>
<p>We now have a simple function that accepts one required argument, <b>arg_a</b>, and another optional argument, <b>arg_b</b>. Optional arguments, as their name suggests, don't always need to be supplied; if we just call <code>myFunction(30)</code>, the terminal won't flip out because the function we defined will simply provide the value 20 for arg_b if we don't pass one. However, we still need to provide something for the required argument, so we provide 30 when calling myFunction() as shown above.</p>
<p>In most programming languages, function arguments are passed in the order that the function's prototype - the first line that begins with the <b>def</b> keyword - specifies. In Python, this is also the case, but we're not limited to that method. Thus, we could have also entered <code>myFunction(20,50)</code> in the terminal to assign the optional argument a value of 50. We also have the option of explicitly stating which arguments we want to supply; when we use this method, order doesn't matter because the function will refer to the names we wrote in the function call, and map the values after those names to the corresponding arguments in the function. Try entering <code>myFunction(arg_b=90, arg_a=10)</code> into your terminal:</p>
<pre>
>>> myFunction(arg_b=90, arg_a=10)
Sum is: 100
</pre>
<p>The 'return' present at the end of this function is not strictly required. You can leave it out, and Python - by default - will just return from the function, returning 'None.'</p>
<p>Python functions, unless otherwise specified, return 'None' by default. We could just as easily have specified an explicit return value: Intead of writing 'return' we could write 'return arg_a + arg_b' and then call our function like so:</p>
<pre>
>>> temp = myFunction(20)
Sum is: 40
>>> print temp
40
</pre>
<p>Which assigns the return value from <code>myFunction(20)</code> to the variable <b>temp</b>.</p>
<h1>Modules</h1>
<p>Alright, so now we know how to define a basic function in Python, and can call the function. Our function has required arguments, as well as optional arguments set to default values. We know how to selectively supply arguments out of order, by using their names during a function call, and we can modify our function to return a value that we can then assign to a variable of our choosing.</p>
<p>Wouldn't it be nice if we could just have our function in a separate file for later use, or for purposes of easier modification? After all, if we wanted to make changes to a function we define through the interactive shell, we would have to define it yet again, then indent for every statement we want to enter; this becomes tedious pretty fast.</p>
<p>In Python, reusable code is typically made available through a <b>.py</b> extension file. Create a new text document in a directory of your choosing, with this extension - let's go with <b>SimpleModule.py</b>. Once you've created this file, open it up, and type this out in the file:</p>
<pre>
def myFunction(arg_a, arg_b=20):
    print "Sum is: %s" % (arg_a + arg_b)
    return arg_a + arg_b
</pre>
<p>Remember to use consistent indentation - if it's tabs, then a tab for every code block (code blocks are anything that follow a statement that ends with a colon ':' character). If you use spaces, know that most people agree on using four spaces for every code block.</p>
<p>Okay, now that you're done typing that in just save the file. Afterwards, open your terminal and navigate to the directory you saved this file in. Run Python to get your interactive terminal, then enter <code>import SimpleModule</code> to cause Python to import your source code file as a module, for use in this shell session.</p>
<p>Now, enter <code>var = SimpleModule.myFunction(11)</code> followed by <code>print var</code> and you should see this:</p>
<pre>
>>> import SimpleModule
>>> var = SimpleModule.myFunction(11)
Sum is: 31
>>> print var
31
</pre>
<p>As you can see, this is a more convenient approach to writing and using functions, or really any objects/classes we define: stick it all in a file, then load the file as a module and call/construct/use what you need as a member of the module. That explains why we call <code>SimpleModule.myFunction(11)</code> as shown: because it's a function included in the SimpleModule Python source file. There's an even faster way of using code we define in a Python source file for tests, which I'll describe in a future post.</p>
<h1>The Grid-Generating Python Function</h1>
<p>Let's briefly revisit the JavaScript grid of coordinates discussed in the <a href="https://jpiedra.github.io/2015/09/MazeGenPython1A/" title="Maze Generation with Python -- Prelude">previous post.</a> As shown below, <code>mazeGraph.nodes[]</code> is a 2-dimensional array.</p>
<pre>
var mazeGraph = function() {
	this.nodes = 			
	[				//Outer List
		[1,0,1,0,1,0,1,0,1,0,1,0], 	//Inner Lists
		[0,0,0,0,0,0,0,0,0,0,0,0],
		[1,0,1,0,1,0,1,0,1,0,1,0],
		[0,0,0,0,0,0,0,0,0,0,0,0],
		[1,0,1,0,1,0,1,0,1,0,1,0],
		[0,0,0,0,0,0,0,0,0,0,0,0],
		[1,0,1,0,1,0,1,0,1,0,1,0],
		[0,0,0,0,0,0,0,0,0,0,0,0],
		[1,0,1,0,1,0,1,0,1,0,1,0],
		[0,0,0,0,0,0,0,0,0,0,0,0],
		[1,0,1,0,1,0,1,0,1,0,1,0],
		[0,0,0,0,0,0,0,0,0,0,0,0] 	//End of Inner Lists	
	];				//End of Outer List
};
</pre>
<p>This worked well enough for the JS game, as I was merely concerned with getting a basic example of a game up and running. A more robust, stand-alone game would probably aim for generating mazes of arbitrary dimensions on the fly. For that, a function can prove very useful.</p>
<p>Before even writing a single line of code, it's important to take a moment and consider the general process used in creating this object. We won't be able to reuse this code in Python, so we need to describe such a process in order to figure out what we need to do to get a 2d-list in Python, especially if we want a function to do it for us.</p>
<ol>
<li>First, an empty list is created.</li>
<li>We then fill that list with several other lists.</li>
<li>The embedded lists must be made equal in length (store the same number of items).</li>
<li>Every list filled in Step 3 is then initialized with the values we need them to store.</li>
</ol>
<h1>Step One: Create an Empty List</h1>
<p>Now, we already know how to create and fill out a list in Python - we learned how to do this in the last post. If we wanted to write a simple function that returns a list, doing so would be similar but with an additional step - after creating the list, we also must set it as the value to be returned. The example used in the previous post, <code>empty_li = []</code>, does two things in a single assignment: it creates a list (that's the pair of square brackets), and then assigns that resulting list to the variable <b>empty_li</b>.</p>
<p>To make our function return a list, we can do the same thing, with an additional step at the end: return the list variable. Opting for a more descriptive variable name, this leaves us with:</p>
<pre>
# Step 1: An empty list is created.
def CreateGrid():
    grid = []
    return grid
</pre>
<p>We still need to address the other three steps in our list, otherwise we have a pretty useless function (after all, writing <code>mylist = []</code> is much easier than writing and using this function). Here's where the arguments help: we can pass our function integer arguments that correspond to both the number of rows (embedded lists) we want in our returned list, and to the number of columns (elements inside the embedded lists) we want each row to store. Our function header can look like <code>def CreateGrid(rows, cols):</code> as a result - and if we remember that default arguments are supported in Python, we can change it further still to <code>def CreateGrid(rows=7, cols=7):</code>. Now all that's left is to use those arguments in the function to perform the grunt work of initializing a blank grid.</p>
<h1>Step Two: Fill the Empty List... with Lists</h1>
<p>Let's begin with the portion that requires us to <i>fill that list with several other lists</i>. In the previous post, we described two methods of creating lists - the empty list, which we used above in our function definition, and the list initialized using the <code>range(start, stop [,step])</code> method. We're going to modify our function to use an altered version of the range initializion code from the first post, leaving us with this:</p> 
<pre>
# Step 2: We fill the empty list with several other lists.
def CreateGrid(rows=7, cols=7):
    grid = [ <b style="color: red;">[] for row in range(0, rows)</b> ]
    return grid
</pre> 
<p>Our list assignment statement is modified to fill it with empty lists using a for-loop and the range method. Compare this statement with a previous example, <code>li = [v for v in range(0, 10)]</code>, and you'll notice that not much else is different - aside from the presence of an empty list before the for-loop begins. In the previous example, <b>v</b> is used as an index to iterate through every value in the range of numbers 0 up to 10, and the numeric value of the index is what we want to be added to the list upon every iteration. Our <b>grid</b> assignment statement uses an empty list instead, stating that for every iteration in the range 0 up to the value of rows, we want an empty list to get added to grid. For example, if we just use the default argument value, then five empty lists, [ ], will be added to the <b>grid</b>.</p>
<h1>Step Three: Fill the Embedded Lists</h1>
<p>Now we need to initialize the embedded lists, making them <i>equal in length</i>. We're going to do this using nested for-loops.</p>
<pre>
# Step 3: We fill the embedded lists with the same amount of elements.
def CreateGrid(rows=7, cols=7):
    grid = [ <b style="color: red">[] for row in range(0, rows)</b> ]
    <b style="color: blue">for row in range(0, rows):
        grid[row] = [ 0 for col in range(0, cols) ]</b>
    return grid 
</pre>
<p>The first of these loops, <code>for row in range(0, rows):</code> doesn't assign anything, it just iterates through every embedded list in <b>grid</b> using an index - <b>row</b> is the index we'll use to iterate, and <b>rows</b> is the upper limit for iteration, the value of the argument that gets passed to this function. If you've written code in either Java or C/C++, this is analagous to a for-loop in those languages, <code>for (i = 0; i < rows; i++)</code>, only we just name our index once (<b>row</b>, intead of <b>i</b>), and the range method handles iteration for us, using the values we pass it as the starting point (<b>0</b> instead of <b>i = 0</b>), the upper limit (<b>rows</b> instead of <b>i < rows</b>), and iterating one value at a time because we don't specify that third, optional <code>[, step]</code> argument that the range method can accept. Keep that third argument in mind, because in our final step we're going to use it to modify the value of list elements by a certain offset.</p>
<p>The second of these loops, <code>[ 0 for col in range(0, cols) ]</code> is similar to the list initialization in the previous post, <code>li = [v for v in range(0, 10)]</code>, only this time for every iteration through the range method we enter the value zero in the list. By now, it should be clear that this way of using range in a for-loop can be used to create a list full of: each value in a range of numbers, empty lists, a specific number, or plenty of other things. After we finish creating a list full of zero's (<b>cols</b>-many zeros), we assign that cols-wide list to the embedded list <b>grid[row]</b>, and repeat this process for every embedded list: <code>grid[row] = [ 0 for col in range(0, cols) ]</code>; the for-loop using the <b>row</b> index will handle iterating through every embedded list.</p>
<h1>Step Four: Modify the Embedded Lists</h1>
<p>When I initially designed this grid for use in the JavaScript game, I made a minor design flaw. Padding should be added in all directions for every node (everywhere you see a <b>1</b>), for display purposes (we get a nice, solid wall around our maze) mainly. I did this for all nodes except the ones on the top and the left-most side of this grid. We're going to create our nodes keeping this in mind (and the purpose of these nodes will be explained in the next post, where a maze generation algorithm is presented).</p>
<pre>
def CreateGrid(rows=7, cols=7):
    grid = [ <b style="color: red">[] for row in range(0, rows)</b> ]
    <b style="color: blue">for row in range(0, rows):
        grid[row] = [ 0 for col in range(0, cols) ]</b>
    <b style="color: green">for row in range(1, rows, 2):
        for col in range(1, cols, 2):
            grid[row][col] = 1</b>
    return grid 
</pre>

















