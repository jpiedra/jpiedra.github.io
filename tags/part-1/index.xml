<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jonathan Piedra</title>
    <link>http://jpiedra.github.io/tags/part-1/index.xml</link>
    <description>Recent content on Jonathan Piedra</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://jpiedra.github.io/tags/part-1/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>A simple build script</title>
      <link>http://jpiedra.github.io/article/simple-build-script/</link>
      <pubDate>Wed, 01 Feb 2017 10:51:38 -0500</pubDate>
      
      <guid>http://jpiedra.github.io/article/simple-build-script/</guid>
      <description>&lt;p&gt;Today we go over the process of writing a very simple Bash script. We&amp;rsquo;ll be able to detect whether a build for a &lt;a href=&#34;https://gohugo.io/overview/quickstart/&#34;&gt;Hugo static site&lt;/a&gt; is present, push the files to a Git repository for our website, and automate all the steps involved.&lt;/p&gt;

&lt;p&gt;
&lt;h2&gt;Version 1&lt;/h2&gt;&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll begin by showing the code, then explain my process:&lt;/p&gt;

&lt;pre&gt;
#!/bin/bash

build_dir=/var/www/html/blog-dev/public
deploy_dir=/var/www/html/blog-live/jpiedra.github.io

if [ -d $build_dir ]
then
  echo &#34;BUILD FOUND, DETAILS:&#34;
  echo $(stat $build_dir)
  cd $deploy_dir &amp;&amp; rm -rf *
  cp -rp $build_dir/* $deploy_dir
  cd $deploy_dir &amp;&amp; git status; git add -A; git commit -m &#34;[Scripted Deploy $(date)]&#34;; git push
else
  echo &#34;NO BUILD FOUND&#34;
  echo &#34;  Run &#39;hugo&#39; to &#34;
  echo &#34;  create latest build&#34;
fi
&lt;/pre&gt;

&lt;p&gt;We begin by setting two variables, &lt;b&gt;build_dir&lt;/b&gt; and &lt;b&gt;deploy_dir.&lt;/b&gt; These store string values indicating the locations of where our built Hugo site&amp;rsquo;s files reside, and the directory where those files should be copied to, respectively. In this case, &lt;b&gt;deploy_dir&lt;/b&gt; is a GitHub Pages repository, the files used therein are the same ones responsible for powering this website!&lt;/p&gt;

&lt;h2&gt;Testing for Build Directory&lt;/h2&gt;

&lt;p&gt;The bulk of this script begins where the &lt;i&gt;if.. ..fi&lt;/i&gt; structure is shown. This conditional structure begins with a &lt;a href=&#34;http://linuxcommand.org/lc3_man_pages/testh.html&#34;&gt;test.&lt;/a&gt; Now, because we&amp;rsquo;re writing a Bash script, rather than using the command line, we have a built-in operator available to us, the square brackets [ ]. These are used to perform any test in a Bash script, thus instead of writing &lt;i&gt;test -d /some/directory&lt;/i&gt; we can instead write &lt;i&gt;[ -d /some/directory ]&lt;/i&gt;.&lt;/p&gt;

&lt;p&gt;The -d switch allows us to test whether the provided argument is a directory. The test returns 0 or 1, true and false respectively, depending on whether the provided argument is detected as a valid directory. In this script, we test the value stored in &lt;b&gt;$build_dir&lt;/b&gt; (thus, the dollar sign) to check whether a build folder exists in our Hugo site directory - which, by default, would be called &lt;i&gt;public&lt;/i&gt; and reside in the Hugo site base directory.&lt;/p&gt;

&lt;p&gt;&lt;i&gt;Tip: you can run the command &lt;b&gt;compgen -b&lt;/b&gt; with the provided -b switch to get a list of all Bash built-ins available to you. Running the command in your terminal, displays the [ ] built-in near the top of the list.&lt;/i&gt;&lt;/p&gt;

&lt;h2&gt;Conditional Execution&lt;/h2&gt;

&lt;p&gt;In the event our test for a directory fails (directory doesn&amp;rsquo;t exist), we simply echo out a diagnostic message (which would best be output to standard error, more on that later). After &lt;i&gt;else&lt;/i&gt; our script prints the messages to stdout, so whatever is echo&amp;rsquo;ed is visible in the terminal.&lt;/p&gt;

&lt;p&gt;If the build directory does exist, we can begin performing the required steps to push our files to the GitHub pages directory, indicated by &lt;b&gt;$deploy_dir.&lt;/b&gt; We&amp;rsquo;ll be making repeated use of a central Bash feature here.&lt;/p&gt;

&lt;h2&gt;Command Substitution&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://tldp.org/LDP/abs/html/commandsub.html&#34;&gt;Command substitution&lt;/a&gt; &amp;ldquo;literally plugs&amp;hellip; command output into another context,&amp;rdquo; as the aforementioned page phrases it. Indeed, by using certain operators built into the Bash language, we can get the output of a command and do with it whatever we want - this usually means assinging said output to a variable, parsing it using some other commands, or even saving it to another file.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll use command substitution twice here, as indicated by &lt;i&gt;$(&amp;hellip;)&lt;/i&gt; where the elipses would be replaced by Bash built-ins or Linux commands. Another form that&amp;rsquo;s available to us uses backticks, but we&amp;rsquo;ll stick with the former operator instead.&lt;/p&gt;

&lt;h2&gt;Deployment Process&lt;/h2&gt;

&lt;p&gt;After echo&amp;rsquo;ing that we&amp;rsquo;ve found the build folder, we run a few commands when the build directory is detected.&lt;/p&gt;

&lt;ol&gt;
    &lt;li&gt;Command substitution is used to capture the output of running &lt;i&gt;stat $build_dir&lt;/i&gt;, thus printing the result of that command to stdout using echo&lt;/li&gt;
    &lt;li&gt;We change into the deployment directory, and remove the files present there, making way for the files from our latest Hugo site build &lt;i&gt;(cd $deploy_dir &amp;&amp; rm -rf *)&lt;/i&gt;&lt;/li&gt;
    &lt;li&gt;The contents of the Hugo site build directory are copied into the deployment directory &lt;i&gt;(cp -rp $build_dir/* $deploy_dir)&lt;/i&gt;&lt;/li&gt;
    &lt;li&gt;Finally, we change into the deployment directory and execute a few standard Git commands, that add/commit/push the new files to the current branch&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A few notes on step 4. The &lt;i&gt;&amp;amp;&amp;amp;&lt;/i&gt; operator ensures that the second command, &lt;i&gt;git status&lt;/i&gt; is only executed if &lt;i&gt;cd&lt;/i&gt; is successful. This is seen elsewhere, in step 2, ensuring we remove the files only if we successfully changed to the desired folder. Also in step 4, we see the final example of command substitution used when we indicate a message for &lt;i&gt;git commit&lt;/i&gt; to use. We capture the output of running the Bash built-in &lt;i&gt;time&lt;/i&gt; and use that as part of the content for our commit message.&lt;/p&gt;

&lt;p&gt;When you run this script, the last part of this deployment process would involve running &lt;i&gt;git push,&lt;/i&gt; so you would be expected to provide your credentials in the terminal to push the latest Hugo site files. In summation, having a script such as this can save precious time, by performing various checks for us along the way as well as eliminating the tedium of typing and executing several commands.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Web API, written using PHP and MySQL - Part 1</title>
      <link>http://jpiedra.github.io/article/php-sql-api-1/</link>
      <pubDate>Sun, 15 Jan 2017 13:20:54 -0500</pubDate>
      
      <guid>http://jpiedra.github.io/article/php-sql-api-1/</guid>
      <description>&lt;p&gt;In this first part of a series on implementing a PHP/MySQL-based API endpoint for our data, we go over some basic principles, as well as stated goals, that will guide the work we&amp;rsquo;ll be undertaking later.&lt;/p&gt;

&lt;p&gt;
&lt;h2&gt;API, defined&lt;/h2&gt;&lt;/p&gt;

&lt;p&gt;An &lt;i&gt;application programming interface&lt;/i&gt;, or API, can be generally defined as a set of routines/sub-routines made available to us. We use these routines in our own applications as defined by the API&amp;rsquo;s documentation, with little concern about &lt;i&gt;how&lt;/i&gt; the routines do what they do for us. The motivation, then, behind using an API can be any of the following:&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;We need a well-defined and well-tested handle to some functionality (creating/closing a file stream, for example)&lt;/li&gt;
    &lt;li&gt;We need to write a script/program that performs some simple task, without completely reinventing the wheel (use somebody else&#39;s library)&lt;/li&gt;
    &lt;li&gt;We need access to data, and have &lt;i&gt;no other way&lt;/i&gt; to access said data than through the set of routines made available to us&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Web API&lt;/h2&gt;

&lt;p&gt;That last bullet point will be the most relevant motivation behind API construction/use in our case. We&amp;rsquo;ll be developing a &lt;a href=&#34;https://en.wikipedia.org/wiki/Web_API&#34;&gt;&lt;i&gt;web API&lt;/i&gt;&lt;/a&gt;. In many cases where we develop a front-end application on the web, the first step in planning this application will involve developing, or deciding on an existing web API to use.&lt;/p&gt;

&lt;p&gt;As the name suggests, a web API lives on the web. Thus, the context for such an API would be web servers, and the exposed routines will be accessible as universal resource indicators (URI&amp;rsquo;s) that can - sometimes - be accessed directly via a web browser. In a hypothetical API that gives us access to a company&amp;rsquo;s employee data, the URI for getting the ten latest employees might be &lt;b&gt;api.acme.org/employees/10&lt;/b&gt;. (such URI&amp;rsquo;s are often referred to as &lt;i&gt;endpoints&lt;/i&gt;)&lt;/p&gt;

&lt;p&gt;Compare the previous explanation with a tradtional, software API, such as the &lt;a href=&#34;https://en.wikipedia.org/wiki/Berkeley_sockets&#34;&gt;Berkeley sockets API&lt;/a&gt; used in *nix operating systems. Simply put, a socket is a data structure that is used to manage and establish TCP/UDP connections and communication between networked devices. An example of a routine exposed through the sockets API is &lt;b&gt;gethostbyname()&lt;/b&gt;, which &amp;ldquo;resolves host names and addresses&amp;rdquo; based on the information provided to this routine. Just as we get the latest ten employees from the above URI example, using gethostbyname() would return something we expect based on documenation - a NULL pointer in case of an error, or a valid structure corresponding to the detected host.&lt;/p&gt;

&lt;p&gt;Even though the contexts for each are markedly different (web server hosting some application vs. low-level operating system handles), the general principles can be observed: we use a handle associated with some routine or process, and get something back if all goes well.&lt;/p&gt;

&lt;h2&gt;An Example To Follow&lt;/h2&gt;
An example of a web API that I&#39;ve used before is the &lt;a href=&#34;http://docs.brightcove.com/en/video-cloud/media/guides/search_videos-guide.html&#34;&gt;Brightcove Media API&lt;/a&gt;. Though currently deprecated, it provides a clear example of a well-defined API we will use to guide the creation of a new one.

&lt;ul&gt;
    &lt;li&gt;An endpoint we can access via JavaScript AJAX calls&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Query_string&#34;&gt;Query strings&lt;/a&gt; are appended to the endpoint, and allow us to make granular requests for data&lt;/li&gt;
    &lt;li&gt;The requested data is returned to us in JavaScript Object Notation (JSON), a widely-supported format easily adapted to web applications&lt;/li&gt;
&lt;/ul&gt;

Putting this all together, we would make a request such as 
&lt;pre&gt;api.brightcove.com/services/library?command=search_videos&amp;page_size=3&amp;video_fields=id,name&lt;/pre&gt; 
and get back a JSON object, with a bunch of nested objects for each single video that matches the request. The start of our query string is the ? mark, and what follows is a query string where each field/value pair is separated by the &amp; symbol. A field/value pair consists of the left-hand value (an option that impacts the request we&#39;re making), an = sign, and the right-hand value that defines the option preceding it in some way.

Which video fields do we want for each video object we&#39;re returned? Well, note the last field/value set, where &lt;b&gt;video_fields&lt;/b&gt; is followed by a comma-separated list of fields - &lt;b&gt;id,name&lt;/b&gt;. This type of form for writing requests, gives us a compact way of expressing granular requests in a single statement. We can imagine the series of comma-separated fields as corresponding to the columns of a database table. The JSON video objects we get back, then, would correspond to rows that reside in that table.

&lt;h2&gt;Summary&lt;/h2&gt;

&lt;p&gt;With this explanation of &lt;i&gt;what&lt;/i&gt; a web API does and looks like, we&amp;rsquo;ll move on to our next article in the series by describing an example API we&amp;rsquo;ll create using PHP and MySQL for the programming language that powers the API, and the database system that stores our information, respectively. We&amp;rsquo;ll also go over some general features or details of PHP/MySQL that we&amp;rsquo;ll need to know in order to write the API.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>