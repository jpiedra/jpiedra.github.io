<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jonathan Piedra</title>
    <link>http://jpiedra.github.io/tags/es5/index.xml</link>
    <description>Recent content on Jonathan Piedra</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://jpiedra.github.io/tags/es5/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>JavaScript Design Patterns: Constructor</title>
      <link>http://jpiedra.github.io/article/js-constructor/</link>
      <pubDate>Thu, 02 Feb 2017 11:39:57 -0500</pubDate>
      
      <guid>http://jpiedra.github.io/article/js-constructor/</guid>
      <description>&lt;p&gt;This first installment in a series discussing various JavaScript design patterns covers one of the most basic patterns available, the &lt;i&gt;constructor pattern.&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2&gt;Object Literals&lt;/h2&gt;

&lt;p&gt;Those of us who write JavaScript are familiar with the fastest way of creating an object, assinging an &lt;i&gt;object literal&lt;/i&gt; to a variable:&lt;/p&gt;

&lt;pre&gt;
var person = {
    name: &#34;Jonathan Piedra&#34;,
    greeting: function() {
        console.log(&#34;Hi, I&#39;m &#34; + this.name);
    };
};
&lt;/pre&gt;

&lt;p&gt;While simple to grasp and convenient enough for a small application or script, this won&amp;rsquo;t do as soon as we have a need for a programmatic method of creating similar objects with different information.&lt;/p&gt;

&lt;h2&gt;The Constructor&lt;/h2&gt;

&lt;p&gt;Fortunately, in JavaScript, we do have a method of object construction that hews closer to what one would encounter in C++ or Python. It involves defining a special type of function that follows these conventions:&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;Name of the function corresponds with the capitalized name of the object (examples: Animal, Person, Car) of which we want to create unique instances&lt;/li&gt;
    &lt;li&gt;We specify parameters to this function, generally used to set the properties that an instance created using the function should have&lt;/li&gt;
    &lt;li&gt;The &lt;i&gt;this&lt;/i&gt; keyword, similar to how we use it in an object literal, is used to refer to properties that will be unique to each instance&lt;/li&gt;
    &lt;li&gt;Finally, methods are defined on the &lt;i&gt;prototype&lt;/i&gt; level! (more on this later)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let&amp;rsquo;s put this all together with an example that will create Person objects:&lt;/p&gt;

&lt;pre&gt;
// a
function Person(name) {
    this.name = name;   
};

// b
Person.prototype.greeting = function() {
    console.log(&#34;Hi, I&#39;m &#34; + this.name);    
};

// c
var jon = new Person(&#34;Jonathan Piedra&#34;);
jon.greeting();
// Hi, I&#39;m Jonathan Piedra
&lt;/pre&gt;

&lt;p&gt;Segment A consists of the function that manages object creation. We name it Person, as each instance created using this function should be a Person object. A single parameter, &lt;i&gt;name&lt;/i&gt;, is specified; thus, when we create instances using this function (Segment C) we have to pass in one argument, that&amp;rsquo;s used to assign the instance&amp;rsquo;s name property, marked using the &lt;i&gt;this&lt;/i&gt; keyword.&lt;/p&gt;

&lt;p&gt;Segment B defines a method for &lt;i&gt;all Person objects&lt;/i&gt;. The importance of defining object methods in this way is explained in detail below; for now, all we need to know is that using this approach is considered a best practice. We ensure a single definition for the method &lt;i&gt;greeting()&lt;/i&gt; exists.&lt;/p&gt;

&lt;p&gt;Finally, in Segment C, we use the constructor method defined in Segment A. Again, similar to the process used in C++ or other C-like languages, the &lt;i&gt;new&lt;/i&gt; keyword is used, and the function is called with a single string literal passed in. This argument, as we see in the first/only line of the &lt;i&gt;Person&lt;/i&gt; method, is used to set the &lt;i&gt;name&lt;/i&gt; property that belongs to our new instance, &lt;i&gt;jon&lt;/i&gt;.&lt;/p&gt;

&lt;h2&gt;Why Not Inline Methods?&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s return our attention to Segment B. Though we decided to define &lt;i&gt;greeting()&lt;/i&gt; outside of the function body for the Person constructor, there&amp;rsquo;s nothing stopping us from refactoring the constructor like so:&lt;/p&gt;

&lt;pre&gt;
function Person(name) {
    this.name = name;
    this.greeting = function() {
        console.log(&#34;Hi, I&#39;m &#34; + this.name);
    };
};
&lt;/pre&gt;

&lt;p&gt;However, it&amp;rsquo;s important to understand why this is discouraged. When creating a constructor, anything defined &lt;i&gt;inline&lt;/i&gt;, or inside the function body, using the &lt;i&gt;this&lt;/i&gt; keyword will become a property or method that each instance has a unique copy of. In effect, this results in every instance of Person having their &amp;ldquo;own&amp;rdquo; version of &lt;i&gt;greeting&lt;/i&gt;.&lt;/p&gt;

&lt;p&gt;For properties that describe unique attributes, like a name or ID, this is what we want! However, for a method that provides functionality that all instances of an object have in common, this presents problems. The &lt;i&gt;greeting()&lt;/i&gt; method should do the same thing regardless of &lt;i&gt;which Person object&lt;/i&gt; it is being called from; additionally, if we ever want to change what that method does, then doing that when every object instance has it&amp;rsquo;s own copy of the method will prove unnecessarily difficult.&lt;/p&gt;

&lt;h2&gt;Prototypal Inheritance&lt;/h2&gt;

&lt;p&gt;The best practice for defining methods used by constructed objects, involves defining those methods on the Prototype level. In JavaScript, objects are defined along a prototypal chain. What this means, is that all objects - objects we define as literals, through constructors, as well as primitive types like Object and even Array - reside somewhere on a prototype &amp;ldquo;chain.&amp;rdquo; At the top of this chain would be Object, the primitive JavaScript type; at the bottom, custom objects like Person which a programmer defines.&lt;/p&gt;

&lt;p&gt;Inheritance in JavaScript involves an object we create inheriting the methods and properties we define somewhere along the chain (through a previous custom object), as well as whatever methods and properties are defined by objects that reside earlier along that chain (such as primitive types). This means that even a Person instance, like any custom type, will inherit the methods defined in Object&amp;rsquo;s prototype, because it is defined before any other object (it is, after all, the base from which any JavaScript object derives).&lt;/p&gt;

&lt;p&gt;This &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object&#34;&gt;Mozilla Developer Network page&lt;/a&gt; describes the Object primitive in greater detail. We see that, for example, the property &lt;i&gt;constructor&lt;/i&gt; is defined through the Object prototype - thus, referred to as &lt;i&gt;Object.prototype.constructor&lt;/i&gt;. If Person resides on the prototype chain, and comes well after the Object prototype, it follows that Person objects will also have inherited &lt;i&gt;constructor&lt;/i&gt; from Object&amp;rsquo;s prototype (which specifies the constructor used to create the object):&lt;/p&gt;

&lt;pre&gt;
...
jon.constructor
// function Person()
&lt;/pre&gt;

&lt;p&gt;JavaScript wouldn&amp;rsquo;t be as useful if we weren&amp;rsquo;t able to define our own, Prototype-level methods and properties that are automatically available to objects we create. Of course, we are able to do this for custom object types, and the form for doing so is:&lt;/p&gt;

&lt;pre&gt;
MyObject.prototype.MyFunction = function() { ... };
&lt;/pre&gt;

&lt;p&gt;Where &lt;i&gt;MyObject&lt;/i&gt; and &lt;i&gt;MyFunction&lt;/i&gt; can be identifiers of our choosing. Defining methods for objects this way ensures that any object we create of type MyObject (or that &lt;i&gt;extends&lt;/i&gt; from MyObject) will have access to MyFunction. However, this also results in &lt;i&gt;one definition for the function, MyFunction()&lt;/i&gt; being created; this definition is available to all objects we create of type MyObject. Instead of having their own copies, they just point to the Prototype definition of the method they inherited.&lt;/p&gt;

&lt;h2&gt;Person Constructor, Revisited&lt;/h2&gt;

&lt;p&gt;Turning back to our custom Person constructor, the decision to define &lt;i&gt;greeting()&lt;/i&gt; on the prototype level should make more sense now. To further cement this knowledge, let&amp;rsquo;s see what happens when we don&amp;rsquo;t follow the aforementioned practice:&lt;/p&gt;

&lt;pre&gt;
function Person(name) {
    this.name = name;
    this.greeting = function() {
        console.log(&#34;Hi, I&#39;m &#34; + this.name);
    };
};

var jon = new Person(&#34;Jonathan&#34;);
var rob = new Person(&#34;Rob&#34;);

jon.greeting(); // Hi, I&#39;m Jonathan
rob.greeting(); // Hi, I&#39;m Rob
&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s worth mentioning that, given how we&amp;rsquo;ve defined our constructor, the properties and methods for Person objects are mutable; we can change their values. Being able to change the name property might not be so bad, because at most it will only impact that particular Person&amp;rsquo;s name. For methods, though, the implication is that now our instances of a particular type (Person) will no longer provide reliable functionality; if it&amp;rsquo;s possible to change what &lt;i&gt;greeting()&lt;/i&gt; does for each instance, we can&amp;rsquo;t reliably expect calling that method will do what we need it to:&lt;/p&gt;

&lt;pre&gt;
jon.greeting = function() {
    console.log(&#34;I am NOT &#34; + this.name);
};

jon.greeting(); // I am NOT Jonathan
rob.greeting(); // Hi, I&#39;m Rob
&lt;/pre&gt;

&lt;p&gt;In contrast, Prototypal method definition ensures against such a scenario. Any changes to the Prototype&amp;rsquo;s methods will be reflected in all of the object&amp;rsquo;s instances:&lt;/p&gt;

&lt;pre&gt;
function Person(name) {
    this.name = name;   
};

Person.prototype.greeting = function() {
    console.log(&#34;Hi, I&#39;m &#34; + this.name);    
};

var jon = new Person(&#34;Jonathan&#34;);
var rob = new Person(&#34;Rob&#34;);

jon.greeting(); // Hi, I&#39;m Jonathan
rob.greeting(); // Hi, I&#39;m Rob

// Oh, we need to change greeting...
Person.prototype.greeting = function() {
    console.log(&#34;My name is &#34; + this.name);
};

jon.greeting(); // My name is Jonathan
rob.greeting(); // My name is Rob
&lt;/pre&gt;

&lt;p&gt;Using the Prototypal approach to method definition, we ensure that changes made to common functionality will be reflected across all objects of a type, reducing the likelihood of errors as well as headaches.&lt;/p&gt;

&lt;p&gt;&lt;i&gt;The subject matter here is loosely adapted from, and greatly informed by Addy Osmani&amp;rsquo;s in-depth book, &lt;a href=&#34;https://addyosmani.com/resources/essentialjsdesignpatterns/book/&#34;&gt;&lt;b&gt;Learning JavaScript Design Patterns&lt;/b&gt;&lt;/a&gt;. Check out the book for great explanations on this and other design patterns.&lt;/i&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>