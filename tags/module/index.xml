<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jonathan Piedra</title>
    <link>http://jpiedra.github.io/tags/module/index.xml</link>
    <description>Recent content on Jonathan Piedra</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://jpiedra.github.io/tags/module/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>JavaScript Design Patterns: Module</title>
      <link>http://jpiedra.github.io/article/js-module/</link>
      <pubDate>Sun, 10 Sep 2017 17:48:30 -0400</pubDate>
      
      <guid>http://jpiedra.github.io/article/js-module/</guid>
      <description>&lt;p&gt;In the second installation of this series on JavaScript design patterns and their implementation, we take a look at the &lt;i&gt;module pattern.&lt;/i&gt; By combining two commonly used features in the language, we can create robust interfaces that hide member variables and methods as we see fit.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2&gt;The Object Literal, Revisited&lt;/h2&gt;

&lt;p&gt;In the previous article for this series, we introduced the object literal. This is a simple container that we use in JavaScript to create an object, with member variables and methods, which is then assigned to a variable and available like so:&lt;/p&gt;

&lt;pre&gt;
var person = {
    name: &#34;Jonathan Piedra&#34;,
    greeting: function() {
        console.log(&#34;Hi, I&#39;m &#34; + this.name);
    };
};

console.log(person.name);   // &#34;Jonathan Piedra&#34;
person.greeting();          // &#34;Hi, I&#39;m Jonathan Piedra&#34;
&lt;/pre&gt;

&lt;p&gt;The object literal helps us organize our code. Member variables and functions are stored and accessed in the variable named &lt;i&gt;person&lt;/i&gt;. We can think of &lt;i&gt;person&lt;/i&gt; as a rudimentary type of module, as it keeps all pertinent member data available through a name we assign it (through the variable). This is preferable to having the same variables and functions scattered throughout our source code.&lt;/p&gt;

&lt;h2&gt;I Want My Space: Privacy in JavaScript&lt;/h2&gt;

&lt;p&gt;For people with a background in other programming languages, such as C++ or Java, something may have jumped out by now in this example. When we talk about member data in most languages, we&amp;rsquo;re also provided with access modifiers through keywords like &lt;i&gt;public&lt;/i&gt; and &lt;i&gt;private&lt;/i&gt; that specify whether or not we want such member data to be accessed from whatever the &amp;ldquo;global&amp;rdquo; context is (for example, in &amp;ldquo;main&amp;rdquo; if we&amp;rsquo;re writing C++).&lt;/p&gt;

&lt;p&gt;We don&amp;rsquo;t have such keywords available to us in ES5, the version available on most browsers at the moment. However, data privacy is possible in JavaScript and involves the use of a feature of the language that can take some getting used to at first, but becomes very easy after repeated use.&lt;/p&gt;

&lt;h2&gt;Functions And Scope&lt;/h2&gt;

&lt;p&gt;While the sort of block that gets created when we create object literals (everything between curly brackets) cannot render certain data private, functions in JavaScript do create a scope that - by default - prevents anything declared within the function&amp;rsquo;s body from being accessible anywhere else, as long as we declare this data using the &lt;i&gt;var&lt;/i&gt; keyword:&lt;/p&gt;

&lt;pre&gt;
function writeMessage() {
    var secret = &#34;I&#39;m not available.&#34;;
    console.log(secret);
};

writeMessage();         // &#34;I&#39;m not available&#34;
console.log(secret);    // undefined
&lt;/pre&gt;

&lt;p&gt;We don&amp;rsquo;t have a way of accessing the variable &lt;i&gt;secret&lt;/i&gt; that was created in the function&amp;rsquo;s body, because it&amp;rsquo;s only accessible from within the scope that was created when we declared this function. However, anything &lt;i&gt;else that was created or included in the function declaration&lt;/i&gt; will have access to the variables within.&lt;/p&gt;

&lt;p&gt;We can get a little closer to privacy in an object. Writing a function that returns an object seems possible. The object, because it was declared inside of a function, will continue to have access to whatever other variables were set inside the function.&lt;/p&gt;

&lt;pre&gt;
function buildModule() {
    var privateName = &#34;James Bond&#34;;

    function privateMethod() {
        console.log(privateName);
    };

    return {
        publicMethod: privateMethod
    };
};

var obj = buildModule();    // buildModule returns an object stored in obj.
obj.publicMethod();         // its only member is a reference to private, function-scoped &#39;privateMethod&#39;.

console.log(privateName);   // still can&#39;t access this (it only exists in the function&#39;s scope)

&lt;/pre&gt;

&lt;p&gt;This gives us part of the solution. While we now know of a way to achieve data privacy, we need a way of combining this with object creation in order to make it really useful. Enter the IIFE.&lt;/p&gt;

&lt;h2&gt;Immediately Invoked Function Expression (IIFE)&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s return for a second to the concept of a module. We need a way of declaring an object that provides access to member variables and data as desired, once we define the module. We would prefer to create, then store this object in a variable, like we did with &lt;i&gt;person&lt;/i&gt;, for later use in our source code.&lt;/p&gt;

&lt;p&gt;The most common way to immediately create and store such an object, store it into a variable, is through &lt;a href=&#34;http://benalman.com/news/2010/11/immediately-invoked-function-expression/&#34;&gt;the IIFE.&lt;/a&gt; An IIFE is a type of function that is written using a specific form to both declare, then immediately call it, after declaration. This is in contrast with the typical way of creating a function, which we saw above with &lt;i&gt;writeMessage&lt;/i&gt;.&lt;/p&gt;

&lt;pre&gt;
// declared, then immediately called
var obj = (function(){
    var privateName = &#34;James Bond&#34;;

    function privateMethod() {
        console.log(privateName);
    };

    return {
        publicMethod: privateMethod
    };
})();

obj.publicMethod();
&lt;/pre&gt;

&lt;p&gt;Instead of declaring our function, and then calling it - returning an object and storing it in &lt;i&gt;obj&lt;/i&gt; - we write an IIFE. Everything wrapped inside the first pair of parentheses is called immediately. This results in everything declared inside the anonymous function happening right away, with the resulting object returned and stored in &lt;i&gt;obj&lt;/i&gt;. Afterwards, we use the the object as our module, calling its methods as in the previous example.&lt;/p&gt;

&lt;p&gt;Other than the fact that we use an IIFE to immediately call the logic contained in the function, nothing else has changed with respect to the module object. It still has a single method, a reference to &lt;i&gt;privateMethod&lt;/i&gt; which is otherwise not accessible from the global context, and that single method lets us print out the contents of &lt;i&gt;privateName&lt;/i&gt;, another variable that is only available inside the function&amp;rsquo;s (IIFE&amp;rsquo;s) scope.&lt;/p&gt;

&lt;h2&gt;Tying It Together: A Trivial UI&lt;/h2&gt;

&lt;p&gt;So we now know an IIFE can be used in JavaScript to setup data privacy inside of a module. What generally happens, is that we set up an IIFE that returns an object, storing that object in a variable in the global context. The object returned is our module, and it can have tightly controlled access to &amp;ldquo;private&amp;rdquo; vars declared inside of the IIFE&amp;rsquo;s function body, as well as functions. These vars and functions end up being the private members of the module: we make them public by adding a reference to them in the returned object. We did just that in the previous example, by creating a key called &lt;i&gt;publicMethod&lt;/i&gt; which is a reference to the IIFE-scoped function &lt;i&gt;privateMethod&lt;/i&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s wrap this article up by providing an example somewhat closer to reality. We&amp;rsquo;ll show a module that sets up a very simple UI based on whether the user of our module provides valid parameters. If so, then the method &lt;i&gt;setup&lt;/i&gt; will successfully add an event listener to the element we provided the module. When clicked, the element we passed in will be set to execute a function that is &amp;ldquo;private,&amp;rdquo; otherwise inaccessible beyond the IIFE&amp;rsquo;s scope:&lt;/p&gt;

&lt;pre&gt;
// a trivial UI module
var myUI = (function(apiEndpoint, elem){
  var endpoint = apiEndpoint || null;
  var button = elem || null;
  
  // only assigned to the element if one was passed in
  // this function is private to the IIFE scope, can&#39;t be used elsewhere.
  function fireAjaxRequest() {
    console.log(&#34;AJAX Request: Status 200&#34;);
  };
  
  // if user passed in valid values, &#39;elem&#39; gets an event listener assigned
  // this function is private to the IIFE scope, can&#39;t be used elsewhere.
  function bindAjaxRequest() {
    button.addEventListener(&#34;click&#34;, fireAjaxRequest);
  };
  
  // exposed through &#39;setup&#39; in the returned object
  function privateSetup() {
    if (typeof endpoint === &#39;string&#39; &amp;&amp; button) {
        console.log(&#34;performing UI setup&#34;);
      bindAjaxRequest();
    };
  };
  
  return {
    setup: privateSetup
  };
})(&#34;api.acme.org/employee&#34;, document.getElementById(&#34;fireRequest&#34;));

myUI.setup();
&lt;/pre&gt;

&lt;p&gt;In a future post, I&amp;rsquo;ll demonstrate a more complete version of a UI module that I developed. It&amp;rsquo;s very similar to what&amp;rsquo;s demonstrated here, with the IIFE containing workhorse functions that are either exposed through the returned object, or called conditionally based on whether the user initialized the module with valid values.&lt;/p&gt;

&lt;p&gt;Combining object literals with the privacy introduced by functions, and IIFE&amp;rsquo;s, is a valuable way to create modules with public and private member variables and methods. These same techniques will be useful in a later post, where the singleton pattern is explained as a way of ensuring only one instance of an object exists for use at a given time.&lt;/p&gt;

&lt;p&gt;&lt;i&gt;The subject matter here is loosely adapted from, and greatly informed by Addy Osmani&amp;rsquo;s in-depth book, &lt;a href=&#34;https://addyosmani.com/resources/essentialjsdesignpatterns/book/&#34;&gt;&lt;b&gt;Learning JavaScript Design Patterns&lt;/b&gt;&lt;/a&gt;. Check out the book for great explanations on this and other design patterns.&lt;/i&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>